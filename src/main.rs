use std::fs::File;
use std::io::{BufRead, Write};

use anyhow::Context;
use apple_clis::cli::{self, CodeSign, Commands, Init, IosDeploy, Security, Simctl, Spctl, XcRun};
use apple_clis::codesign;
use apple_clis::shared::identifiers::DeviceName;
use apple_clis::shared::ExecInstance;
use apple_clis::xcrun::XcRunInstance;
use apple_clis::{ios_deploy::IosDeployCLIInstance, security, spctl};
use camino::{Utf8Path, Utf8PathBuf};
use clap::{CommandFactory, Parser};
use tracing::*;
use tracing_subscriber::filter::LevelFilter;
use tracing_subscriber::EnvFilter;

fn main() -> anyhow::Result<()> {
	let config = cli::CliArgs::parse();
	if config.human_output() {
		let env_filter = EnvFilter::builder()
			.with_default_directive(LevelFilter::INFO.into())
			.from_env_lossy();
		tracing_subscriber::fmt().with_env_filter(env_filter).init();
	}

	trace!("Config: {:?}", config);

	match config.command {
		Commands::Init(Init::NuShell { auto, raw_script }) => match (auto, raw_script) {
			(false, true) => {
				println!("# A script autogenerated by `apple-clis init nushell --raw-script`");
				println!("# To install, check the documentation of `apple-clis init nushell --auto`");
				clap_complete::generate(
					clap_complete_nushell::Nushell,
					&mut cli::CliArgs::command(),
					"apple-clis",
					&mut std::io::stdout(),
				);
			}
			(true, false) => {
				// write completions
				{
					// open ~/.apple-clis.nu
					let path = dirs::home_dir()
						.context("No home directory found to install ~/.apple-clis.nu to")?
						.join(".apple-clis.nu");

					let mut completions = Vec::new();
					clap_complete::generate(
						clap_complete_nushell::Nushell,
						&mut cli::CliArgs::command(),
						"apple-clis",
						&mut completions,
					);

					std::fs::write(&path, &completions)
						.context(format!("Failed to write completion script to {:?}", path))?;
					info!("Completion script written to {:?}, now attempting to install it", path);
				}
				// add source ~/.apple-clis.nu
				{
					let nu_cli_path =
						which::which("nu").context("Couldn't locate `nu` binary on your system")?;
					let config_path = bossy::Command::pure(nu_cli_path)
						.with_args(["-c", "$nu.config-path"])
						.run_and_wait_for_string()
						.context("Running `nu -c '$nu.config-path'` failed")?;
					let config_path = config_path.trim();

					let path = Utf8PathBuf::from(config_path);
					let file =
						File::open(&path).context(format!("Cannot open config.nu file at {:?}", &path))?;
					let reader = std::io::BufReader::new(file);
					// if there is a line that contains "source ~/.apple-clis.nu" then don't add it
					if reader.lines().map_while(Result::ok).any(|line| {
						line
							.contains("source ~/.apple-clis.nu")
					}) {
						info!("~/.apple-clis.nu already sourced in your nu config");
					} else {
						let mut file = std::fs::OpenOptions::new()
							.append(true)
							.open(&path)
							.context(format!("Cannot open config.nu file at {:?}", &path))?;
						writeln!(file, "source ~/.apple-clis.nu")
							.context(format!("Cannot write to config.nu file at {:?}", &path))?;
						info!("~/.apple-clis.nu added to your nu config");
					}
				}
			}
			_ => unreachable!("Clap arguments should prevent this"),
		},
		Commands::IosDeploy(ios_deploy) => {
			let ios_deploy_instance = IosDeployCLIInstance::try_new_from_which()?;
			match ios_deploy {
				IosDeploy::Detect => {
					let devices = ios_deploy_instance.detect_devices()?;
					println!("{} real devices found with `ios-deploy`:", devices.len());
					for device in devices {
						println!("Device: {:?}", device);
					}
				}
				IosDeploy::Upload { app_path } => {
					let path = match app_path {
						Some(p) => p,
						None => {
							// find directory/file ending in .app
							cli::glob("**/*.app")?
						}
					};
					let devices = ios_deploy_instance.detect_devices()?;
					let device = match devices.first() {
						Some(d) => d,
						None => {
							anyhow::bail!("No devices found to upload to")
						}
					};
					ios_deploy_instance.upload_bundle(device, path)?;
				}
			}
		}
		// Commands::CargoBundle(cargo_bundle) => {
		// 	let cargo_bundle_instance = cargo_bundle::CargoBundleInstance::new(
		// 		config.args.try_get_cargo_path()?,
		// 		// config.args.try_get_manifest_path()?,
		// 	);
		// 	// set cwd to manifest dir
		// 	std::env::set_current_dir(config.args.try_get_manifest_path()?)?;
		// 	match cargo_bundle {
		// 		CargoBundle::Ios => {
		// 			cargo_bundle_instance.bundle_ios()?;
		// 		}
		// 	}
		// }
		Commands::Security(security) => {
			let security_instance = security::SecurityCLIInstance::try_new_from_which()?;
			match security {
				Security::Certs => {
					let teams = security_instance.get_developer_certs()?;
					println!("{} development teams found with `security`:", teams.len());
					for team in teams {
						println!("Team: {:?}", team);
					}
				}
				Security::Pems => {
					let pems = security_instance.get_developer_pems()?;
					println!("{} development pems found with `security`:", pems.len());
					for pem in pems {
						println!("Pem: {:#?}", pem);
					}
				}
			}
		}
		Commands::Spctl(spctl) => {
			let spctl_instance = spctl::SpctlCLIInstance::try_new_from_which()?;
			match spctl {
				Spctl::AssessApp { app_path } => {
					let path = match app_path {
						Some(p) => p,
						None => {
							// find directory/file ending in .app
							cli::glob("**/*.app")?
						}
					};
					spctl_instance.assess_app(path)?;
				}
			}
		}
		Commands::CodeSign(codesign) => {
			let codesign_instance = codesign::CodesignCLIInstance::try_new_from_which()?;
			match codesign {
				CodeSign::Display { app_path } => {
					let path = match app_path {
						Some(p) => p,
						None => {
							// find directory/file ending in .app
							cli::glob("**/*.app")?
						}
					};
					let output = codesign_instance.display(path)?;
					println!("{}", output);
				}
				CodeSign::Sign { app_path } => {
					let path = match app_path {
						Some(p) => p,
						None => {
							// find directory/file ending in .app
							cli::glob("**/*.app")?
						}
					};
					let security_instance = security::SecurityCLIInstance::try_new_from_which()?;
					let certs = security_instance.get_developer_certs()?;
					let cert = match certs.first() {
						Some(c) => c,
						None => {
							anyhow::bail!("No developer certs found to sign with")
						}
					};
					codesign_instance.sign(cert, path)?;
				}
			}
		}
		Commands::XcRun(xcrun) => {
			let xcrun_instance = XcRunInstance::try_new_from_which()?;
			match xcrun {
				XcRun::Simctl(simctl) => {
					let simctl_instance = xcrun_instance.simctl();
					match simctl {
						Simctl::List => {
							let devices = simctl_instance.list()?;
							let devices = devices.devices().collect::<Vec<_>>();
							println!("{} devices found with `xcrun simctl list`:", devices.len());
							for device in devices {
								println!(
									"Device found: Name = {}, simulator running = {}",
									device.name,
									device.ready()
								);
							}
						}
						Simctl::Boot { ipad, iphone, name } => {
							let device_name: DeviceName = match name {
								Some(n) => n,
								None => {
									let list = simctl_instance.list()?;
									match (ipad, iphone) {
										(true, false) => {
											let latest_ipad = list.ipads().max().context("No simulator iPads found!")?;
											latest_ipad.clone().into()
										}
										(false, true) => {
											let latest_iphone = list
												.iphones()
												.max()
												.context("No simulator iPhones found!")?;
											latest_iphone.clone().into()
										}
										_ => unreachable!("Clap arguments should prevent this"),
									}
								}
							};
							info!("Booting device: {}", device_name);
							simctl_instance.boot(device_name)?;
						}
					}
				}
			}
		}
	}

	Ok(())
}
